---
title: jvm老年代垃圾收集器 CMS 工作原理
tags:
  - jvm
  - cms
  - 老年代收集器
categories:
  - jvm
  - 实战笔记
keywords: 
date: 2019-07-23
updated: 2019-10-31
description: 
top_img:

---

1. CMS 垃圾回收的基本原理
    - 标记情理法
        - 通过追踪 GC Roots 方法
        - 看看各个对象是否被 GC Roots 引用
        - 会造成很多内存碎片
2. Stop the World 垃圾回收会如何
    - 系统卡死
    - 垃圾回收线程和系统工作线程尽量同时执行的模式处理
3. CMS 如何实现一边工作同时进行垃圾回收
    - 初始标记
        - 系统工作进程全部停止, 进入"stop the world"
        - 标记出所有GC Roots 直接引用的对象
        - 不去管深层的对象
        - 方法的局部变量 和 类的静态变量是 GC Roots
        - 类的实例变量不是 GC Roots
        - 速度很快, 仅仅标记 GCRoots 直接引用的那些对象
    - 并发标记
        - 可以让系统线程创建各种新的对象继续运行
        - 创建新的对象  存活对象失去引用
        - 垃圾回收线程会尽可能对已有对象进行 GC Roots 追踪
        - 此时会看变量被GC Root 间接引用了, 此时不需回收它
        - 最耗时, 追踪所有对象是否从根源上被 GC Roots 引用了
    - 重新标记
        - 第二阶段, 系统在创建新对象
        - 此时会存在很多存活对象和垃圾对象未被标出
        - 再次进入 Stop the World
        - 重新标记以上情况
        - 速度很快
    - 并发清理
        - 清理掉之前标记的对象
        - 耗时, 但是是和系统线程并发执行, 不影响系统程序执行
- 标记整理法
    - 先标记再整理而后清理
- 清理的时候是标记垃圾对象
    - 并发清理的时候,新进入老年代的就是浮动垃圾, 不会清理
- 1岁 2岁 3岁的对象加起来超过 50%, 此时超过三岁的对象就会直接进入老年代