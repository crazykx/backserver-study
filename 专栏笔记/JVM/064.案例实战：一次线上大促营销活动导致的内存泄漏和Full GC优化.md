---
title: 一次线上大促营销活动导致的内存泄漏和 Full GC优化
tags:
  - jvm
  - full gc
categories:
  - jvm
  - 实战笔记
keywords: 
date: 2019-09-04
updated: 2019-10-31
description: 
top_img:

---



FullGC频繁

- 内存分配不合理, 或多对象进入老年代
- 永久代的类太多,触发FullGC
- 内存泄漏, 内存里驻留了大量对象塞满了老年代, 稍微一些对象进入老年代就会引发 FullGC
- 工程师错误的执行 `System.gc()`

排查: 老年代里驻留了大量的对象, 被塞满了

年轻代稍微有一些对象进入老年代就会触发 Full GC

老年代里驻留了大量的本不应该存在的对象

jhat 适合快速的去分析一下内存快照

使用一个常用的强有力的内存分析工具 **[MAT](http://www.eclipse.org/mat/downloads.php)**

**原因**: 系统做了一个 JVM 本地的缓存, 把很多数据都加载到内存里去缓存起来, 然后提供查询, 但是没有限制本地缓存大小, 并没有使用 LRU 算法之类的算法定期淘汰一些缓存里的数据, 导致缓存在内存里的对象越来越多, 进而造成了内存泄漏

**解决**: 使用类似 EHCache 之类的缓存框架就可以了, 它会固定最多缓存多少个对象, 定期淘汰删除掉一些不怎么访问的缓存, 以便新的数据可以进入缓存中

