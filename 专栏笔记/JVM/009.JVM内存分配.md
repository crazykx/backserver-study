---
title: jvm内存分配
tags:
  - jvm
  - 内存分配
categories:
  - jvm
  - 实战笔记
keywords: 内存分配
date: 2019-07-09
updated: 2019-10-31
description: 
top_img:
---



- 什么时候发生垃圾回收
  + 局部变量, 当存在该局部变量的方法栈帧出栈导致没有任何局部变量引用那个实例对象 --- 不一定立即发生垃圾回收
  + 如果新生代我们预先分配的内存空间几乎被全部对象给占满了, 假设我们代码继续运行,他需要在新生代里去分配一个对象, 若发现新生代内存空间都不够了, 这个时候就会触发一次新生代内存空间的垃圾回收, 新生代内存空间的垃圾回收也称之为"Minor GC" ===>> 尝试把新生代里那些没有人引用的垃圾对象都给回收掉
  + JVM规定: 给每个对象定义了一个对象年龄计数器，在对象在Eden创建并经过第一次Minor GC后仍然存活，并能被Suivivor容纳的话，将会被移动到Survivor空间，并对象年龄设置为1。每经历过Minor GC，年龄就增加1岁，当到一定程度（默认15岁，可以通过参数-XXMaxTenuringThreshold设置），就将会晋升年老代
- 对象分配
  + 新生代垃圾回收之后,因为存活对象太多,导致大量对象直接进入老年代
  + 特别大的超大对象直接不经过新生代就进入老年代  避免从新生代进入老年代的超大复制`
  + 动态对象年龄判断机制
  + 空间担保机制


局部变量不需要垃圾回收, JVM垃圾回收针对的是新生代.老年代,方法区(永久代),不会针对方法的栈帧. 方法一旦执行完毕,栈帧出栈,里面的局部变量直接从内存里清理掉了