1. 日处理数据量在上亿的规模
   - 每分钟执行 500 次数据提取和计算的任务, 五台机器, 每台 接受 100 次任务
   - 每次提取 10000 条数据到内存中计算, 每次计算大概需要 10 秒钟时间
   - 每台机器 是 4核 8G 的配置, JVM 内存 4G, 新生代 和 老年代 分别是 1.5G 内存空间
   - 一条数据平均 20 个字段, 假设平均 下来每条数据 1KB 左右, 每次 10000 条数据 对应 10MB
   - 8:1:1新生代比例, Eden 1.2GB  Survivor 100MB
   - 每台机器每分钟 Eden 区分配 1G 的内存左右
   - 差不多 一分钟就填满了 Eden  区, 此时 老年代是空的且内存大于新生代总对象大小 1.2GB, 直接进行 Minor GC
   - 每次计算花费 10 秒钟, 假设 80 个计算任务都执行结束了, 还有 20 个计算任务还在计算中, 即 200MB 还是存活对象, 不能被垃圾回收掉
   - 此时 Survivor 区只有 100MB, 小于 此时存活的对象, 那么此时 200 MB对象 会全部进入老年代
   - 大约在 7 分钟后, 老年代存入 1.4GB, 剩余不到 100MB, 几乎快满了
   - 大概第八分钟时, 判断老年代可用空间小于历次进入老年代的对象大小, 直接进行老年代 Old GC
   - 七八分钟进行一次 Old GC, 频率相当高了
2. 解决
   - 最大的问题就是每次 Minor GC 后 Survivor 内存不够, 存放不下存活的对象, 导致对象每次直接进入老年代
   - 此时对生产系统进行调整, 增加新生代的内存比例, 3GB 左右的堆内存, 其中 2GB 分配给新生代, 老年代只需要 1GB, 这样 Survivor 区大概就是 200MB, 每次刚好能放下 MInor GC 过后存活的对象
   - 下一次 Minor GC 这个 Survivor 区的对象对应的计算任务早就结束了, 都是可以回收的
   - 基本上每次极少的对象会进入老年代, Old GC 可能从 几分钟 降低到 几个小时一次
3. 如果该系统的工作负载再次扩大 10 倍时
   - 每次可能加载进 100MB 数据进入内存, 1.6G 的 Eden区 而言, 10 多秒就会迅速塞满对象, 就会触发 Young GC, 每次处理 10 秒钟才会处理完成的话, 每隔 10 多秒就会有 1GB 的数据进入老年代
   - 每10 多秒就会放入1GB 的数据进入老年代中, 下一次 10 多秒过后, 又会放入 1G 多数据, 此时必然会提前触发 Full GC 回收老年代里的 1GB 的对象
   - 每分钟就会触发好几次 Old GC
4. 使用大内存机器优化
   - 更换机器 为 16核 32GB 的高配置机器
   - Eden 空间会扩大十倍, 比如 16GB
   - 每次加载 100MB 进入内存, 要两分多才会触发 Young GC, 降低 Young GC的频率
   - 每次存活对象可能也就 几百 MB 而已, 不会超过 1GB
   - Survivor 区域可能会分配有 2GB 内存
   - 不需要使用 G1 垃圾回收器来优化, 因为即使每次 两分钟一次 Young GC的停顿时间, 每次 1 秒钟, 但是他是一个后台程序, 不直接面向用户, 也不会影响用户