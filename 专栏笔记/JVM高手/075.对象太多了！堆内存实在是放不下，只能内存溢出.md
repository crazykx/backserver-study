真正最容易引发内存溢出的, 其实是我们平时系统创建出来的对象实在太多了, 最终导致系统的内存溢出

高并发场景下导致 YoungGC 过后存活的对象太多, 很多对象没有处理完, 进入老年代 老年代很快就会放满

老年代放满, 就会触发 Full GC, 老年代GC后依然存在很多对象, 年轻代一批对象等待着进入老年代 ==> 内存溢出



有限的内存中存放了过多的对象, 而且大多数都是存活的, 此时即使GC过后还是大部分都存活, 没有空间存放更多对象



发生堆内存溢出场景:

高并发请求, 请求量大, 导致大量对象都是存活的, 继续放入新的对象不行了

系统内存泄漏问题, 对象都是活的, 没有及时取消对他们的引用, 导致触发 GC 还是无法回收



系统负载过高  内存泄漏