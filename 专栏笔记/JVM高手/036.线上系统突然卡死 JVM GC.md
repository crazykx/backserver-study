1. JVM 运行的系统最怕什么

   1. 核心内存区域: 堆内存

   2. GC ROOTs 就是类的静态变量, 方法的局部变量

      + 平时我们最经常创建对象的地方就是在方法里面, 一旦一个方法运行完毕之后, 方法的局部变量就没了, 此时之前所有在方法区里面创建的对象就是垃圾了
      + 99% 都是这种垃圾对象
      + 年轻代 GC 期间都要停止系统程序的运行

   3. 年轻代没有什么好调优的

      1. 运行逻辑简单, 效率高
      2. 内存足够的话, 几个小时触发一次新生代 GC

   4. 大内存的话, 比如机器是 64G 的话

      1. 新生代 Eden 区可能占比较大
      2. 类似 Kafka Elasticsearch 之类的大数据相关的系统, 都是部署在大机器上
      3. 如果此时机器负载非常的高, 对于大数据系统是可能每秒几万请求到上面组件的
      4. 可能导致 Eden 区几十 G 内存频繁塞满要触发垃圾回收
      5. 每次垃圾回收要停止 Kafka Elasticsearch 的运行, 然后执行垃圾回收, 可能有的请求一旦卡死几秒钟就会超时报错, 此时可能导致系统崩溃
      6. 使用 G1 垃圾回收器控制系统停止时间, 每次 G1 运行一段时间后就针对少部分的 Region 进行垃圾回收, 此时就仅仅停顿固定时间, 腾出空间让系统继续运行

   5. 频繁老年代 GC

      1. 对象年龄大

      2. 动态年龄判断

      3. 新生代垃圾回收过后, 内存存活对象太多, 此时直接进入老年代

    主要是第二 三 两个条件
   
   ​	老年代 GC 通常比新生代慢 10 倍以上, 无论是 CMS 还是 G1
   
   6. JVM 性能优化到底在优化什么
      1. 因为内存分配  参数设置不合理, 导致对象频繁进入老年代, 然后频繁触发老年代 GC, 导致系统频繁的每个几分钟就要卡死一会

